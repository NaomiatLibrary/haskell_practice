# haskell practice
英語jupyter notebook : https://github.com/jamesdbrock/learn-you-a-haskell-notebook
## Haskellとは
純粋関数型プログラミング言語

### 参照透明性
関数は副作用を持たず、どんな時も同じ引数に対して同じ結果を返す

副作用…関数が持つ計算の結果を返す以外の役割のこと。例えばターミナルに出力するとか？

### 型
静的型付け言語であり、型推論してくれる
### 遅延評価
結果が必要になるまで関数を実行しない。参照透明なのでそれでも結果は変わらない

### リストとタプル
リストは違う型のものを入れられない、タプルは入れられる。
リストは長さが違っても同じ型、タプルは長さが違うと違う型。

### 型クラス
型クラスのインスタンスである型は、その型クラスが記述する振る舞いを実装する。
具体的には型クラスはメソッドという関数をもち、ある型が型クラスのインスタンスである時、それらのメソッドがその型ではどういう意味を成すのかを定義する。

#### 型クラス制約
```
:t (==)
(==) :: Eq a => a -> a -> Bool
```
のEq aのこと。
#### 型注釈
```
read "5" :: Int
```
の`::Int`のこと。
#### 多相定数
```
:t minBound
(Bounded a) => a
```
みたいなもの。あらゆる数は多相定数として表現されていて、Num型クラスの全てのインスタンスとして振る舞うことができる。
### 純粋性
Haskellはpurely functional programming languageを売りにしている。



### IO型
ではどうやっているのか？→「動作を返す」関数(IO型)を使っている。mainはこの型の値で定義するようになっている、そしてコンパイルされた実行ファイルはその動作を実行する。
#### IOモナド

## 文法
### letとwhere
変数を束縛する文法。
letは式(値を持つ)、whereはそうではない
letはスコープに局所的でガードを跨いで使えない、whereはガードを跨いで使える
### パターンマッチとcase式
case式は式なのでどこでも使える
パターンマッチは関数を定義するときだけ
### 高階関数
#### カリー化関数
複数の引数を取る代わりに、常にちょうど一つの引数を取る関数
その次の引数を受け取る関数を返す。
#### ラムダ式
`\xs -> length xs > 15`みたいにバックスラッシュから初めて高階関数に渡す関数を作る。

### 関数合成と`$`
`$`は優先度が最も低い関数実行の二項演算子だと考えれば良さそう。関数合成は引数が1個の関数を繋げるのしか使えないので注意（もちろんカリー化してあるので無理やり引数1個の関数にすれば良い）。さらに、「関数の適用は、すべての演算の中で最も高い優先度を持」つので、関数の適用の方が関数の合成より先に行われてしまい、合成失敗する書き方が多いので注意。例えば、
```
sum $ map snd path --これはOK
sum . map snd $ path -- これもOK
sum . (map snd) path -- これはNG
```
## その他用語など
## 述語
真理値を返す関数
## リストへの追加・リストへの結合
先頭に追加するのは早い(`:`)、最後に結合するのは遅い…(`++`)